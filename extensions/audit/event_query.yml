---
# getNetworkSwitchMtu - checked
cisco.meraki.networks_switch_mtu_info:
  query: >-
    if .meraki_response then
      .meraki_response |
      if .overrides and (.overrides | length > 0) then
        . as $parent |
        [
          $parent.overrides[] |
          . as $override |
          # Create entries for each switch serial
          ($override.switches // [])[] |
          {
            name: (. | tostring),
            canonical_facts: {
              ansible_product_serial: (. | tostring)
            },
            facts: {
              device_type: "switch",
              mtu_size: $override.mtuSize,
              default_mtu_size: $parent.defaultMtuSize
            }
          }
        ]
      else
        []
      end
    else []
    end

# Devices
cisco.meraki.devices_info:
  query: >-
    if .meraki_response then
      .meraki_response | [.] | flatten |
      map({
        name: ((.name | select(. != "")) // (.productType + "-" + .serial)),
        canonical_facts: {
          ansible_product_serial: .serial,
          hostname: (.lanIp // "")
        },
        facts: {
          device_type: .productType,
          meraki_network_id: .networkId,
          ansible_hostname: (.lanIp // ""),
          ansible_product_name: .model,
          ansible_bios_version: .firmware,
          macaddress: .mac
        }
      })
    else []
    end

# getDeviceSwitchPort
cisco.meraki.devices_switch_ports_info:
  query: >-
    if .meraki_response then
      [.meraki_response] |
      map({
        name: (.name // ("port-" + (.portId | tostring))),
        canonical_facts: {
          ansible_product_serial: .module.serial
        },
        facts: {
          device_type: "switch",
          port_id: .portId,
          vlan_id: .vlan,
        }
      })
    else []
    end

# getNetworkSwitchStack
cisco.meraki.networks_switch_stacks_info:
  query: >-
    if .meraki_response then
      .meraki_response |
      . as $parent |
      [
        # Create entries for each switch serial in the stack
        ($parent.serials // [])[] |
        {
          name: (. | tostring),
          canonical_facts: {
            ansible_product_serial: (. | tostring)
          },
          facts: {
            device_type: "switch",
            stack_id: ($parent.id | tostring),
            stack_name: $parent.name,
            virtual_mac: $parent.virtualMac,
            is_monitor_only: $parent.isMonitorOnly
          }
        }
      ]
    else []
    end

# getNetworkSwitchStackRoutingInterfaces
cisco.meraki.networks_switch_stacks_routing_interfaces_info:
  query: >-
    if .meraki_response then
      (.meraki_response | if type == "array" then . else [.] end) |
      map({
        name: .name,
        canonical_facts: {
          ansible_product_serial: .serial,
          hostname: .interfaceIp
        },
        facts: {
          device_type: "switch",
          interface_id: .interfaceId,
          uplink: {
            ipv4_enabled: .uplinkV4,
            ipv6_enabled: .uplinkV6
          },
        }
      })
    else []
    end

# updateDeviceSwitchPort
cisco.meraki.devices_switch_ports:
  query: >-
    if .meraki_response then
      [.meraki_response] |
      map({
        name: (.name // ("port-" + (.portId | tostring))),
        canonical_facts: {
          ansible_product_serial: .module.serial
        },
        facts: {
          device_type: "switch",
          port_id: .portId,
          module: {
            model: .module.model,
            serial: .module.serial,
            slot: .module.slot
          }
        }
      })
    else []
    end

# getOrganizationSwitchPortsBySwitch
cisco.meraki.organizations_switch_ports_by_switch_info:
  query: >-
    if .meraki_response then
      (.meraki_response | if type == "array" then . else [.] end) |
      map({
        name: .name,
        canonical_facts: {
          ansible_product_serial: .serial,
          hostname: (.mac // "")
        },
        facts: {
          device_type: "switch",
          mac_address: .mac,
          model: .model,
          switch_info: {
            network_name: .network.name,
            network_id: .network.id
          },
        }
      })
    else []
    end

# getDeviceSwitchPortsStatuses
cisco.meraki.devices_switch_ports_statuses_info:
  query: >-
    if .meraki_response then
      (.meraki_response.items | if type == "array" then . else [.] end) |
      map({
        name: .name,
        canonical_facts: {
          ansible_product_serial: .serial,
          hostname: (.mac // "")
        },
        facts: {
          device_type: "switch",
          mac_address: .mac,
          model: .model,
          switch_info: {
            network_name: .network.name,
            network_id: .network.id
          },
        }
      })
    else []
    end

# getNetworkSwitchAccessPolicies
cisco.meraki.networks_switch_access_policies_info:
  query: >-
    if .meraki_response then
      (.meraki_response | if type == "array" then . else [.] end) |
      map({
        name: .name,
        canonical_facts: {
          ansible_machine_id: (.accessPolicyNumber | tostring)
        },
        facts: {
          device_type: "switch",
          access_policy_number: .accessPolicyNumber,
          access_policy_type: .accessPolicyType,
        }
      })
    else []
    end

# getNetworkSwitchSettings
cisco.meraki.networks_switch_settings_info:
  query: >-
    if .meraki_response then
      .meraki_response |
      if .powerExceptions and (.powerExceptions | length > 0) then
        . as $parent |
        [
          $parent.powerExceptions[] |
          {
            name: .serial,
            canonical_facts: {
              ansible_product_serial: .serial
            },
            facts: {
              device_type: "switch",
              power_exception: {
                power_type: .powerType
              },
              network_settings: {
                vlan: $parent.vlan,
                use_combined_power: $parent.useCombinedPower,
              }
            }
          }
        ]
      else
        []
      end
    else []
    end

# updateNetworkSwitchAccessPolicy
cisco.meraki.networks_switch_access_policies:
  query: >-
    if .meraki_response then
      (.meraki_response | if type == "array" then . else [.] end) |
      map({
        name: .name,
        canonical_facts: {
          ansible_machine_id: (.accessPolicyNumber | tostring)
        },
        facts: {
          device_type: "switch",
          access_policy_number: .accessPolicyNumber,
          access_policy_type: .accessPolicyType,
        }
      })
    else []
    end

# createNetworkSwitchStackRoutingInterface
cisco.meraki.networks_switch_stacks_routing_interfaces:
  query: >-
    if .meraki_response then
      (.meraki_response | if type == "array" then . else [.] end) |
      map({
        name: .name,
        canonical_facts: {
          ansible_product_serial: .serial,
          hostname: .interfaceIp
        },
        facts: {
          device_type: "switch",
          interface_id: .interfaceId,
          vlan_id: .vlanId,
          interface_ip: .interfaceIp,
        }
      })
    else []
    end

# getNetworkSwitchStp
cisco.meraki.networks_switch_stp_info:
  query: >-
    if .meraki_response then
      .meraki_response |
      if .stpBridgePriority and (.stpBridgePriority | length > 0) then
        . as $parent |
        [
          $parent.stpBridgePriority[] |
          . as $priority_config |
          (
            # Create entries for each switch serial
            ($priority_config.switches // [])[] |
            {
              name: (. | tostring),
              canonical_facts: {
                ansible_product_serial: (. | tostring)
              },
              facts: {
                device_type: "switch",
                stp_priority: $priority_config.stpPriority,
                rstp_enabled: $parent.rstpEnabled
              }
            }
          )
        ] | flatten
      else
        []
      end
    else []
    end

# createNetworkSwitchQosRule / updateNetworkSwitchQosRule / deleteNetworkSwitchQosRule
cisco.meraki.networks_switch_qos_rules_order:
  query: >-
    if .meraki_response then
      (.meraki_response | if type == "array" then . else [.] end) |
      map({
        name: ("qos-rule-" + (.id | tostring)),
        canonical_facts: {
          ansible_machine_id: (.id | tostring)
        },
        facts: {
          device_type: "switch",
          qos_rule: {
            id: (.id | tostring),
            vlan: .vlan,
            protocol: .protocol,
            src_port: .srcPort,
            src_port_range: .srcPortRange,
            dst_port: .dstPort,
            dst_port_range: .dstPortRange,
            dscp: .dscp
          }
        }
      })
    else []
    end

# cycleDeviceSwitchPorts
cisco.meraki.devices_switch_ports_cycle:
  query: >-
    if .meraki_response then
      (.meraki_response.ports // []) |
      map({
        name: ("port-" + .),
        canonical_facts: {
          ansible_machine_id: .
        },
        facts: {
          device_type: "switch",
          port_identifier: .
        }
      })
    else []
    end

# getNetworkSwitchAccessControlLists - not good
cisco.meraki.networks_switch_access_control_lists_info:
  query: >-
    if .meraki_response then
      (.meraki_response.rules // []) |
      to_entries |
      map({
        name: (.value.comment // ("acl-rule-" + (.key | tostring))),
        canonical_facts: {
          ansible_machine_id: (
            (.value.dstCidr // "") + "-" +
            (.key | tostring)
          )
        },
        facts: {
          device_type: "switch",
          acl_rule: {
            comment: .value.comment,
            policy: .value.policy,
            ip_version: .value.ipVersion,
            protocol: .value.protocol,
            src_cidr: .value.srcCidr,
            src_port: .value.srcPort,
            dst_cidr: .value.dstCidr,
            dst_port: .value.dstPort,
            vlan: .value.vlan,
            rule_index: .key
          }
        }
      })
    else []
    end

# createNetworkSwitchStack / deleteNetworkSwitchStack
cisco.meraki.networks_switch_stacks:
  query: >-
    if .meraki_response then
      .meraki_response |
      . as $parent |
      [
        # Create entries for each switch serial in the stack
        ($parent.serials // [])[] |
        {
          name: .,
          canonical_facts: {
            ansible_product_serial: .
          },
          facts: {
            device_type: "switch",
            stack_id: ($parent.id | tostring),
            stack_name: $parent.name,
            workflow_id: ($parent.workflowId | tostring)
          }
        }
      ]
    else []
    end

# updateNetworkSwitchSettings
cisco.meraki.networks_switch_settings:
  query: >-
    if .meraki_response then
      .meraki_response |
      . as $parent |
      [
        # Create entries for each switch with power exceptions
        ($parent.powerExceptions // [])[] |
        {
          name: .serial,
          canonical_facts: {
            ansible_product_serial: .serial
          },
          facts: {
            device_type: "switch",
            power_exception: {
              power_type: .powerType
            },
            network_settings: {
              vlan: $parent.vlan,
              use_combined_power: $parent.useCombinedPower,
            }
          }
        }
      ]
    else []
    end

# getNetworkSwitchStackRoutingInterfaceDhcp
cisco.meraki.networks_switch_stacks_routing_interfaces_dhcp_info:
  query: >-
    if .meraki_response then
      .meraki_response |
      . as $parent |
      [
        # Create entries for each device with fixed IP assignment
        ($parent.fixedIpAssignments // [])[] |
        {
          name: (.name // .mac),
          canonical_facts: {
            hostname: .ip,
            ansible_machine_id: .mac
          },
          facts: {
            device_type: "switch",
            fixed_ip_assignment: {
              mac: .mac,
              ip: .ip,
              name: .name
            },
          }
        }
      ]
    else []
    end

# updateNetworkSwitchStackRoutingInterfaceDhcp
cisco.meraki.networks_switch_stacks_routing_interfaces_dhcp:
  query: >-
    if .meraki_response then
      .meraki_response |
      . as $parent |
      [
        # Create entries for each device with fixed IP assignment
        ($parent.fixedIpAssignments // [])[] |
        {
          name: (.name // .mac),
          canonical_facts: {
            hostname: .ip,
            ansible_machine_id: .mac
          },
          facts: {
            device_type: "switch",
            fixed_ip_assignment: {
              mac: .mac,
              ip: .ip,
              name: .name
            },
            dhcp_config: {
              dhcp_mode: $parent.dhcpMode,
              dhcp_lease_time: $parent.dhcpLeaseTime,
              dns_nameservers_option: $parent.dnsNameserversOption,
              boot_options_enabled: $parent.bootOptionsEnabled
            }
          }
        }
      ]
    else []
    end

# getNetworkSwitchDhcpServerPolicy
cisco.meraki.networks_switch_dhcp_server_policy_info:
  query: >-
    if .meraki_response then
      .meraki_response |
      . as $parent |
      [
        (
          # Create entries for each blocked DHCP server
          ($parent.blockedServers // [])[] |
          {
            name: ("blocked-dhcp-server-" + .),
            canonical_facts: {
              ansible_machine_id: .
            },
            facts: {
              device_type: "switch",
              dhcp_server_policy: {
                status: "blocked",
                mac_address: .,
                default_policy: $parent.defaultPolicy,
                arp_inspection_enabled: ($parent.arpInspection.enabled // false)
              }
            }
          }
        ),
        (
          # Create entries for each allowed DHCP server
          ($parent.allowedServers // [])[] |
          {
            name: ("allowed-dhcp-server-" + .),
            canonical_facts: {
              ansible_machine_id: .
            },
            facts: {
              device_type: "switch",
              dhcp_server_policy: {
                status: "allowed",
                mac_address: .,
                default_policy: $parent.defaultPolicy,
                arp_inspection_enabled: ($parent.arpInspection.enabled // false)
              }
            }
          }
        )
      ]
    else []
    end

# updateNetworkSwitchStp
cisco.meraki.networks_switch_stp:
  query: >-
    if .meraki_response then
      .meraki_response |
      if .stpBridgePriority and (.stpBridgePriority | length > 0) then
        . as $parent |
        [
          $parent.stpBridgePriority[] |
          . as $priority_config |
          (
            # Create entries for each switch serial
            ($priority_config.switches // [])[] |
            {
              name: (. | tostring),
              canonical_facts: {
                ansible_product_serial: (. | tostring)
              },
              facts: {
                device_type: "switch",
                stp_priority: $priority_config.stpPriority,
                rstp_enabled: $parent.rstpEnabled
              }
            }
          )
        ] | flatten
      else
        []
      end
    else []
    end

# createNetworkSwitchLinkAggregation / updateNetworkSwitchLinkAggregation / deleteNetworkSwitchLinkAggregation
cisco.meraki.networks_switch_link_aggregations:
  query: >-
    if .meraki_response then
      .meraki_response |
      . as $parent |
      [
        # Create entries for each port in the link aggregation
        ($parent.switchPorts // [])[] |
        {
          name: (.serial + "-port-" + (.portId | tostring)),
          canonical_facts: {
            ansible_product_serial: .serial
          },
          facts: {
            device_type: "switch",
            link_aggregation: {
              aggregation_id: ($parent.id | tostring),
              port_id: (.portId | tostring),
              serial: .serial
            }
          }
        }
      ]
    else []
    end

# getDeviceSwitchRoutingInterfaces / getDeviceSwitchRoutingInterface
cisco.meraki.devices_switch_routing_interfaces_info:
  query: >-
    if .meraki_response then
      (.meraki_response | if type == "array" then . else [.] end) |
      map({
        name: (.name // ("interface-" + (.interfaceId | tostring))),
        canonical_facts: {
          ansible_product_serial: .serial,
          hostname: (.interfaceIp // "")
        },
        facts: {
          device_type: "switch",
          interface_id: (.interfaceId | tostring),
          vlan_id: .vlanId,
          interface_ip: .interfaceIp,
          vrf: (
            if .vrf then
              {
                name: .vrf.name
              }
            else
              {}
            end
          )
        }
      })
    else []
    end

# createDeviceSwitchRoutingInterface / updateDeviceSwitchRoutingInterface / deleteDeviceSwitchRoutingInterface
cisco.meraki.devices_switch_routing_interfaces:
  query: >-
    if .meraki_response then
      [.meraki_response] |
      map({
        name: (.name // ("interface-" + (.interfaceId | tostring))),
        canonical_facts: {
          ansible_product_serial: .serial,
          hostname: (.interfaceIp // "")
        },
        facts: {
          device_type: "switch",
          interface_id: (.interfaceId | tostring),
          vlan_id: .vlanId,
          interface_ip: .interfaceIp,
          vrf: (
            if .vrf then
              {
                name: .vrf.name
              }
            else
              {}
            end
          )
        }
      })
    else []
    end

# updateNetworkSwitchAccessControlLists - no good
cisco.meraki.networks_switch_access_control_lists:
  query: >-
    if .meraki_response then
      (.meraki_response.rules // []) |
      to_entries |
      map({
        name: (.value.comment // ("acl-rule-" + (.key | tostring))),
        canonical_facts: {
          ansible_machine_id: (
            (.value.srcCidr // "") + "-" +
            (.value.dstCidr // "") + "-" +
            (.key | tostring)
          )
        },
        facts: {
          device_type: "switch",
          acl_rule: {
            comment: .value.comment,
            policy: .value.policy,
            ip_version: .value.ipVersion,
            protocol: .value.protocol,
            src_cidr: .value.srcCidr,
            src_port: .value.srcPort,
            dst_cidr: .value.dstCidr,
            dst_port: .value.dstPort,
            vlan: .value.vlan,
            rule_index: .key
          }
        }
      })
    else []
    end

# getNetworkSwitchRoutingMulticast
cisco.meraki.networks_switch_routing_multicast_info:
  query: >-
    if .meraki_response then
      .meraki_response |
      if .overrides and (.overrides | length > 0) then
        . as $parent |
        [
          $parent.overrides[] |
          . as $override |
          (
            # Create entries for each switch serial
            ($override.switches // [])[] |
            {
              name: (. | tostring),
              canonical_facts: {
                ansible_product_serial: (. | tostring)
              },
              facts: {
                device_type: "switch",
                multicast_settings: {
                  igmp_snooping_enabled: $override.igmpSnoopingEnabled,
                  flood_unknown_multicast_traffic_enabled: $override.floodUnknownMulticastTrafficEnabled
                },
                default_settings: {
                  igmp_snooping_enabled: ($parent.defaultSettings.igmpSnoopingEnabled // false),
                  flood_unknown_multicast_traffic_enabled: ($parent.defaultSettings.floodUnknownMulticastTrafficEnabled // false)
                }
              }
            }
          )
        ] | flatten
      else
        []
      end
    else []
    end

# getNetworkSwitchRoutingOspf - not good
cisco.meraki.networks_switch_routing_ospf_info:
  query: >-
    if .meraki_response then
      .meraki_response |
      . as $parent |
      [
        (
          # Create entries for each OSPFv2 area
          ($parent.areas // [])[] |
          {
            name: (.areaName // ("ospf-area-" + (.areaId | tostring))),
            canonical_facts: {
              ansible_machine_id: (.areaId | tostring)
            },
            facts: {
              device_type: "switch",
              ospf_version: "v2",
              ospf_area: {
                area_id: (.areaId | tostring),
                area_name: .areaName,
                area_type: .areaType
              },
              ospf_config: {
                enabled: $parent.enabled,
                hello_timer: $parent.helloTimerInSeconds,
                dead_timer: $parent.deadTimerInSeconds,
                md5_authentication_enabled: ($parent.md5AuthenticationEnabled // false)
              },
              vrf: (
                if $parent.vrf then
                  {
                    name: $parent.vrf.name
                  }
                else
                  {}
                end
              )
            }
          }
        ),
        (
          # Create entries for each OSPFv3 area
          (($parent.v3 // {}).areas // [])[] |
          {
            name: (.areaName // ("ospfv3-area-" + (.areaId | tostring))),
            canonical_facts: {
              ansible_machine_id: ("v3-" + (.areaId | tostring))
            },
            facts: {
              device_type: "switch",
              ospf_version: "v3",
              ospf_area: {
                area_id: (.areaId | tostring),
                area_name: .areaName,
                area_type: .areaType
              },
              ospf_config: {
                enabled: ($parent.v3.enabled // false),
                hello_timer: ($parent.v3.helloTimerInSeconds // 0),
                dead_timer: ($parent.v3.deadTimerInSeconds // 0)
              },
              vrf: (
                if $parent.vrf then
                  {
                    name: $parent.vrf.name
                  }
                else
                  {}
                end
              )
            }
          }
        )
      ]
    else []
    end

# getNetworkSwitchAlternateManagementInterface
cisco.meraki.networks_switch_alternate_management_interface_info:
  query: >-
    if .meraki_response then
      .meraki_response |
      . as $parent |
      [
        # Create entries for each switch with alternate management interface
        ($parent.switches // [])[] |
        {
          name: .serial,
          canonical_facts: {
            ansible_product_serial: .serial,
            hostname: (.alternateManagementIp // "")
          },
          facts: {
            device_type: "switch",
            alternate_management_interface: {
              enabled: $parent.enabled,
              vlan_id: $parent.vlanId,
              protocols: ($parent.protocols // []),
              alternate_management_ip: .alternateManagementIp,
              subnet_mask: .subnetMask,
              gateway: .gateway
            }
          }
        }
      ]
    else []
    end

# getOrganizationConfigTemplateSwitchProfiles
cisco.meraki.organizations_config_templates_switch_profiles_info:
  query: >-
    if .meraki_response then
      (.meraki_response | if type == "array" then . else [.] end) |
      map({
        name: (.name // ("switch-profile-" + (.switchProfileId | tostring))),
        canonical_facts: {
          ansible_machine_id: (.switchProfileId | tostring)
        },
        facts: {
          device_type: "switch",
          switch_profile: {
            profile_id: (.switchProfileId | tostring),
            name: .name,
            model: .model
          }
        }
      })
    else []
    end

# updateNetworkSwitchRoutingOspf - not good
cisco.meraki.networks_switch_routing_ospf:
  query: >-
    if .meraki_response then
      .meraki_response |
      . as $parent |
      [
        (
          # Create entries for each OSPFv2 area
          ($parent.areas // [])[] |
          {
            name: (.areaName // ("ospf-area-" + (.areaId | tostring))),
            canonical_facts: {
              ansible_machine_id: (.areaId | tostring)
            },
            facts: {
              device_type: "switch",
              ospf_version: "v2",
              ospf_area: {
                area_id: (.areaId | tostring),
                area_name: .areaName,
                area_type: .areaType
              },
              ospf_config: {
                enabled: $parent.enabled,
                hello_timer: $parent.helloTimerInSeconds,
                dead_timer: $parent.deadTimerInSeconds,
                md5_authentication_enabled: ($parent.md5AuthenticationEnabled // false)
              },
              vrf: (
                if $parent.vrf then
                  {
                    name: $parent.vrf.name
                  }
                else
                  {}
                end
              )
            }
          }
        ),
        (
          # Create entries for each OSPFv3 area
          (($parent.v3 // {}).areas // [])[] |
          {
            name: (.areaName // ("ospfv3-area-" + (.areaId | tostring))),
            canonical_facts: {
              ansible_machine_id: ("v3-" + (.areaId | tostring))
            },
            facts: {
              device_type: "switch",
              ospf_version: "v3",
              ospf_area: {
                area_id: (.areaId | tostring),
                area_name: .areaName,
                area_type: .areaType
              },
              ospf_config: {
                enabled: ($parent.v3.enabled // false),
                hello_timer: ($parent.v3.helloTimerInSeconds // 0),
                dead_timer: ($parent.v3.deadTimerInSeconds // 0)
              },
              vrf: (
                if $parent.vrf then
                  {
                    name: $parent.vrf.name
                  }
                else
                  {}
                end
              )
            }
          }
        )
      ]
    else []
    end

# getNetworkSwitchDhcpServerPolicyArpInspectionTrustedServers
cisco.meraki.networks_switch_dhcp_server_policy_arp_inspection_trusted_servers_info:
  query: >-
    if .meraki_response then
      (.meraki_response | if type == "array" then . else [.] end) |
      map({
        name: ("trusted-server-" + (.trustedServerId | tostring)),
        canonical_facts: {
          ansible_machine_id: .mac,
          hostname: (.ipv4.address // "")
        },
        facts: {
          device_type: "switch",
          trusted_server: {
            trusted_server_id: (.trustedServerId | tostring),
            mac_address: .mac,
            vlan: .vlan,
            ipv4_address: (.ipv4.address // "")
          }
        }
      })
    else []
    end

# getNetworkSwitchDhcpServerPolicyArpInspectionWarningsByDevice
cisco.meraki.networks_switch_dhcp_server_policy_arp_inspection_warnings_by_device_info:
  query: >-
    if .meraki_response then
      (.meraki_response | if type == "array" then . else [.] end) |
      map({
        name: (.name // .serial),
        canonical_facts: {
          ansible_product_serial: .serial
        },
        facts: {
          device_type: "switch",
          arp_inspection_warning: {
            supports_inspection: .supportsInspection,
            has_trusted_port: .hasTrustedPort,
            url: .url
          }
        }
      })
    else []
    end

# getNetworkSwitchDhcpV4ServersSeen
cisco.meraki.networks_switch_dhcp_v4_servers_seen_info:
  query: >-
    if .meraki_response then
      (.meraki_response | if type == "array" then . else [.] end) |
      [
        .[] |
        . as $dhcp_server |
        (
          # Create entry for the device serial (if device exists)
          if $dhcp_server.device and $dhcp_server.device.serial then
            {
              name: $dhcp_server.device.serial,
              canonical_facts: {
                ansible_product_serial: $dhcp_server.device.serial
              },
              facts: {
                device_type: "switch",
                dhcp_server_seen: {
                  mac_address: $dhcp_server.mac,
                  vlan: $dhcp_server.vlan,
                  ipv4: {
                    address: ($dhcp_server.ipv4.address // ""),
                    subnet: ($dhcp_server.ipv4.subnet // ""),
                    gateway: ($dhcp_server.ipv4.gateway // "")
                  },
                  device_name: ($dhcp_server.device.name // ""),
                }
              }
            }
          else
            empty
          end
        ),
        (
          # Create entries for each switch serial in seenBy
          ($dhcp_server.seenBy // [])[] |
          {
            name: .serial,
            canonical_facts: {
              ansible_product_serial: .serial
            },
            facts: {
              device_type: "switch",
              dhcp_server_seen: {
                mac_address: $dhcp_server.mac,
                vlan: $dhcp_server.vlan,
                client_id: $dhcp_server.clientId,
                type: $dhcp_server.type,
                ipv4: {
                  address: ($dhcp_server.ipv4.address // ""),
                  subnet: ($dhcp_server.ipv4.subnet // ""),
                  gateway: ($dhcp_server.ipv4.gateway // "")
                },
              }
            }
          }
        )
      ] | flatten
    else []
    end

# getNetworkSwitchLinkAggregations
cisco.meraki.networks_switch_link_aggregations_info:
  query: >-
    if .meraki_response then
      (.meraki_response | if type == "array" then . else [.] end) |
      [
        .[] |
        . as $aggregation |
        ($aggregation.switchPorts // [])[] |
        {
          name: (.serial + "-port-" + (.portId | tostring)),
          canonical_facts: {
            ansible_product_serial: .serial
          },
          facts: {
            device_type: "switch",
            link_aggregation: {
              aggregation_id: ($aggregation.id | tostring),
              port_id: (.portId | tostring),
              serial: .serial
            }
          }
        }
      ]
    else []
    end

# getNetworkSwitchQosRules / getNetworkSwitchQosRule
cisco.meraki.networks_switch_qos_rules_order_info:
  query: >-
    if .meraki_response then
      (.meraki_response | if type == "array" then . else [.] end) |
      map({
        name: ("qos-rule-" + (.id | tostring)),
        canonical_facts: {
          ansible_machine_id: (.id | tostring)
        },
        facts: {
          device_type: "switch",
          qos_rule: {
            id: (.id | tostring),
            vlan: .vlan,
            protocol: .protocol,
            src_port: .srcPort,
            src_port_range: .srcPortRange,
            dst_port: .dstPort,
            dst_port_range: .dstPortRange,
            dscp: .dscp
          }
        }
      })
    else []
    end

# getNetworkSwitchRoutingMulticastRendezvousPoints / getNetworkSwitchRoutingMulticastRendezvousPoint
cisco.meraki.networks_switch_routing_multicast_rendezvous_points_info:
  query: >-
    if .meraki_response then
      (.meraki_response | if type == "array" then . else [.] end) |
      map({
        name: ("rendezvous-point-" + (.rendezvousPointId | tostring)),
        canonical_facts: {
          ansible_product_serial: .serial,
          hostname: (.interfaceIp // "")
        },
        facts: {
          device_type: "switch",
          multicast_rendezvous_point: {
            rendezvous_point_id: (.rendezvousPointId | tostring),
            serial: .serial,
            interface_name: .interfaceName,
            interface_ip: .interfaceIp,
            multicast_group: .multicastGroup
          }
        }
      })
    else []
    end

# getDeviceSwitchRoutingStaticRoutes / getDeviceSwitchRoutingStaticRoute - not good
cisco.meraki.devices_switch_routing_static_routes_info:
  query: >-
    if .meraki_response then
      (.meraki_response | if type == "array" then . else [.] end) |
      map({
        name: (.name // ("static-route-" + (.staticRouteId | tostring))),
        canonical_facts: {
          ansible_machine_id: (.staticRouteId | tostring)
        },
        facts: {
          device_type: "switch",
          static_route: {
            route_id: (.staticRouteId | tostring),
            name: .name,
            subnet: .subnet,
            next_hop_ip: .nextHopIp,
            management_next_hop: .managementNextHop,
            advertise_via_ospf_enabled: .advertiseViaOspfEnabled,
            prefer_over_ospf_routes_enabled: .preferOverOspfRoutesEnabled,
            vrf: (
              if .vrf then
                {
                  name: .vrf.name,
                  leak_route_to_default_vrf: .vrf.leakRouteToDefaultVrf
                }
              else
                {}
              end
            )
          }
        }
      })
    else []
    end

# removeNetworkSwitchStack
cisco.meraki.networks_switch_stacks_remove:
  query: >-
    if .meraki_response then
      .meraki_response |
      . as $parent |
      [
        # Create entries for each switch serial in the stack
        ($parent.serials // [])[] |
        {
          name: .,
          canonical_facts: {
            ansible_product_serial: .
          },
          facts: {
            device_type: "switch",
            stack_id: ($parent.id | tostring),
            stack_name: $parent.name,
            is_monitor_only: $parent.isMonitorOnly,
            virtual_mac: $parent.virtualMac
          }
        }
      ]
    else []
    end

# getDeviceSwitchWarmSpare
cisco.meraki.devices_switch_warm_spare_info:
  query: >-
    if .meraki_response then
      .meraki_response |
      if .enabled then
        . as $parent |
        [
          # Create entry for primary switch
          {
            name: $parent.primarySerial,
            canonical_facts: {
              ansible_product_serial: $parent.primarySerial
            },
            facts: {
              device_type: "switch",
              warm_spare: {
                enabled: $parent.enabled,
                role: "primary",
                spare_serial: $parent.spareSerial
              }
            }
          },
          # Create entry for spare switch
          {
            name: $parent.spareSerial,
            canonical_facts: {
              ansible_product_serial: $parent.spareSerial
            },
            facts: {
              device_type: "switch",
              warm_spare: {
                enabled: $parent.enabled,
                role: "spare",
                primary_serial: $parent.primarySerial
              }
            }
          }
        ]
      else
        []
      end
    else []
    end

# getOrganizationSummaryTopSwitchesByEnergyUsage - not good
cisco.meraki.organizations_summary_top_switches_by_energy_usage_info:
  query: >-
    if .meraki_response then
      (.meraki_response | if type == "array" then . else [.] end) |
      map({
        name: (.name // .mac),
        canonical_facts: {
          ansible_machine_id: .mac
        },
        facts: {
          device_type: "switch",
          switch_info: {
            name: .name,
            model: .model,
            mac_address: .mac
          },
          network: (
            if .network then
              {
                id: .network.id,
                name: .network.name
              }
            else
              {}
            end
          ),
          energy_usage: {
            total: .usage.total
          }
        }
      })
    else []
    end

# addNetworkSwitchStack
cisco.meraki.networks_switch_stacks_add:
  query: >-
    if .meraki_response then
      .meraki_response |
      . as $parent |
      [
        # Create entries for each switch serial in the stack
        ($parent.serials // [])[] |
        {
          name: .,
          canonical_facts: {
            ansible_product_serial: .
          },
          facts: {
            device_type: "switch",
            stack_id: ($parent.id | tostring),
            stack_name: $parent.name,
            is_monitor_only: $parent.isMonitorOnly,
            virtual_mac: $parent.virtualMac
          }
        }
      ]
    else []
    end

# getDeviceSwitchRoutingInterfaceDhcp - not good
cisco.meraki.devices_switch_routing_interfaces_dhcp_info:
  query: >-
    if .meraki_response then
      .meraki_response |
      . as $parent |
      [
        # Create entries for each device with fixed IP assignment
        ($parent.fixedIpAssignments // [])[] |
        {
          name: (.name // .mac),
          canonical_facts: {
            hostname: .ip,
            ansible_machine_id: .mac
          },
          facts: {
            device_type: "switch",
            fixed_ip_assignment: {
              mac: .mac,
              ip: .ip,
              name: .name
            },
            dhcp_config: {
              dhcp_mode: $parent.dhcpMode,
              dhcp_lease_time: $parent.dhcpLeaseTime,
              dns_nameservers_option: $parent.dnsNameserversOption,
              boot_options_enabled: $parent.bootOptionsEnabled
            }
          }
        }
      ]
    else []
    end

# getDeviceSwitchRoutingInterfaceDhcp
cisco.meraki.devices_switch_routing_interfaces_dhcp:
  query: >-
    if .meraki_response then
      .meraki_response |
      . as $parent |
      [
        # Create entries for each device with fixed IP assignment
        ($parent.fixedIpAssignments // [])[] |
        {
          name: (.name // .mac),
          canonical_facts: {
            hostname: .ip,
            ansible_machine_id: .mac
          },
          facts: {
            device_type: "switch",
            fixed_ip_assignment: {
              mac: .mac,
              ip: .ip,
              name: .name
            },
            dhcp_config: {
              dhcp_mode: $parent.dhcpMode,
              dhcp_lease_time: $parent.dhcpLeaseTime,
              dns_nameservers_option: $parent.dnsNameserversOption,
              boot_options_enabled: $parent.bootOptionsEnabled
            }
          }
        }
      ]
    else []
    end

# updateNetworkSwitchRoutingMulticast
cisco.meraki.networks_switch_routing_multicast:
  query: >-
    if .meraki_response then
      .meraki_response |
      if .overrides and (.overrides | length > 0) then
        . as $parent |
        [
          $parent.overrides[] |
          . as $override |
          (
            # Create entries for each switch serial
            ($override.switches // [])[] |
            {
              name: (. | tostring),
              canonical_facts: {
                ansible_product_serial: (. | tostring)
              },
              facts: {
                device_type: "switch",
                multicast_settings: {
                  igmp_snooping_enabled: $override.igmpSnoopingEnabled,
                  flood_unknown_multicast_traffic_enabled: $override.floodUnknownMulticastTrafficEnabled
                },
                default_settings: {
                  igmp_snooping_enabled: ($parent.defaultSettings.igmpSnoopingEnabled // false),
                  flood_unknown_multicast_traffic_enabled: ($parent.defaultSettings.floodUnknownMulticastTrafficEnabled // false)
                }
              }
            }
          )
        ] | flatten
      else
        []
      end
    else []
    end

# updateNetworkSwitchDhcpServerPolicy
cisco.meraki.networks_switch_dhcp_server_policy:
  query: >-
    if .meraki_response then
      .meraki_response |
      . as $parent |
      [
        (
          # Create entries for each blocked DHCP server
          ($parent.blockedServers // [])[] |
          {
            name: ("blocked-dhcp-server-" + .),
            canonical_facts: {
              ansible_machine_id: .
            },
            facts: {
              device_type: "switch",
              dhcp_server_policy: {
                status: "blocked",
                mac_address: .,
                default_policy: $parent.defaultPolicy,
                arp_inspection_enabled: ($parent.arpInspection.enabled // false)
              }
            }
          }
        ),
        (
          # Create entries for each allowed DHCP server
          ($parent.allowedServers // [])[] |
          {
            name: ("allowed-dhcp-server-" + .),
            canonical_facts: {
              ansible_machine_id: .
            },
            facts: {
              device_type: "switch",
              dhcp_server_policy: {
                status: "allowed",
                mac_address: .,
                default_policy: $parent.defaultPolicy,
                arp_inspection_enabled: ($parent.arpInspection.enabled // false)
              }
            }
          }
        )
      ]
    else []
    end

# Networks
cisco.meraki.networks_info:
  query: >-
    if .meraki_response then
      .meraki_response | [.] | flatten |
      map({
        name: .name,
        canonical_facts: {
          ansible_machine_id: .id
        },
        facts: {
          device_type: "network",
          meraki_organization_id: .organizationId
        }
      })
    else []
    end

# delete operation returns "meraki_response": null
cisco.meraki.networks:
  query: >-
    if .meraki_response then
      [.meraki_response] |
      map({
        name: .name,
        canonical_facts: {
          ansible_machine_id: .id
        },
        facts: {
          device_type: "switch",
          meraki_organization_id: .organizationId
        }
      })
    else []
    end

# updateDevice does not seem to return productType field
cisco.meraki.devices:
  query: >-
    if .meraki_response then
      .meraki_response | [.] | flatten |
      map({
        name: ((.name | select(. != "")) // (.model + "-" + .serial)),
        canonical_facts: {
          ansible_product_serial: .serial,
          hostname: (.lanIp // "")
        },
        facts: {
          device_type: (if .model | startswith("MV") then "camera"
                    elif .model | startswith("MR") then "wireless"
                    elif .model | startswith("MS") then "switch"
                    elif .model | startswith("MX") then "appliance"
                    else "unknown"
                    end),
          meraki_network_id: .networkId,
          ansible_hostname: (.lanIp // ""),
          ansible_product_name: .model,
          ansible_bios_version: .firmware,
          macaddress: .mac
        }
      })
    else []
    end
