---
# Networks
cisco.meraki.networks_info:
  query: >-
    .meraki_response | [.] | flatten |
     map({
        name: .name,
        canonical_facts: {
          network_id: .id,
          org_id: .organizationId
        },
        facts: {
          device_type: "network"
        }
      })
    | .[]

# delete operation returns "meraki_response": null
cisco.meraki.networks:
  query: >-
    if .meraki_response then
      .meraki_response |
      {
        name: .name,
        canonical_facts: {
          network_id: .id,
          org_id: .organizationId
        },
        facts: {
            device_type: "switch"
        }
      }
    else empty
    end

# Devices
cisco.meraki.devices_info:
  query: >-
    .meraki_response | [.] | flatten |
      map({
          name: ((.name | select(. != "")) // (.productType + "-" + .serial)),
          canonical_facts: {
            ansible_product_serial: .serial,
            macaddress: .mac
          },
          facts: {
            device_type: .productType,
            meraki_network_id: .networkId,
            ansible_hostname: (.lanIp // ""),
            ansible_product_name: .model,
            ansible_bios_version: .firmware,
          }
        })
      | .[]

# updateDevice does not seem to return productType field
cisco.meraki.devices:
  query: >-
    .meraki_response | [.] | flatten |
      map({
          name: ((.name | select(. != "")) // (.model + "-" + .serial)),
          canonical_facts: {
            ansible_product_serial: .serial,
            macaddress: .mac
          },
          facts: {
            device_type: (if .model | startswith("MV") then "camera"
                      elif .model | startswith("MR") then "wireless"
                      elif .model | startswith("MS") then "switch"
                      elif .model | startswith("MX") then "appliance"
                      else "unknown"
                      end),
            meraki_network_id: .networkId,
            ansible_hostname: (.lanIp // ""),
            ansible_product_name: .model,
            ansible_bios_version: .firmware,
          }
        })
      | .[]

# getDeviceSwitchPort
cisco.meraki.devices_switch_ports_info:
  query: >-
    if .meraki_response then
      .meraki_response |
      {
        name: .name,
        canonical_facts: {
          vlan_id: .vlan,
          port_id: .portId,
          ansible_product_serial: .module.serial,
        },
        facts: {
          device_type: "switch",
          port_config: {
            enabled: .enabled,
            type: .type,
            tags: .tags,
            voice_vlan: .voiceVlan,
            allowed_vlans: .allowedVlans,
            link_negotiation: .linkNegotiation,
            link_negotiation_capabilities: .linkNegotiationCapabilities
          },
          poe: {
            enabled: .poeEnabled
          },
          spanning_tree: {
            rstp_enabled: .rstpEnabled,
            stp_guard: .stpGuard
          },
          security: {
            isolation_enabled: .isolationEnabled,
            udld: .udld,
            access_policy_type: .accessPolicyType,
            access_policy_number: .accessPolicyNumber,
            mac_allow_list: .macAllowList,
            mac_whitelist_limit: .macWhitelistLimit,
            sticky_mac_allow_list: .stickyMacAllowList,
            sticky_mac_allow_list_limit: .stickyMacAllowListLimit,
            storm_control_enabled: .stormControlEnabled,
            dai_trusted: .daiTrusted,
            peer_sgt_capable: .peerSgtCapable
          },
          adaptive_policy: {
            group_id: .adaptivePolicyGroupId,
            group_name: .adaptivePolicyGroup.name
          },
          schedule: {
            id: .portScheduleId,
            name: .schedule.name
          },
          advanced: {
            flexible_stacking_enabled: .flexibleStackingEnabled,
            dot3az_enabled: .dot3az.enabled,
            high_speed_enabled: .highSpeed.enabled,
            mirror_mode: .mirror.mode
          },
          profile: {
            enabled: .profile.enabled,
            id: .profile.id,
            iname: .profile.iname
          },
          module: {
            model: .module.model,
            serial: .module.serial,
            slot: .module.slot
          }
        }
      }
    else empty
    end

# getNetworkSwitchMtu
cisco.meraki.networks_switch_mtu_info:
  query: >-
    if .meraki_response then
      .meraki_response |
      {
        name: .name,
        canonical_facts: {
          defaultMtuSize: .defaultMtuSize,
          overrides: .overrides,
        },
        facts: {
            device_type: "switch"
        }
      }
    else empty
    end

# getNetworkSwitchStack
cisco.meraki.networks_switch_stacks_info:
  query: >-
    if .meraki_response then
      .meraki_response |
      {
        name: .name,
        canonical_facts: {
          stack_id: .id,
          virtual_mac: .virtualMac,
        },
        facts: {
          device_type: "switch",
          stack_config: {
            serials: .serials,
            is_monitor_only: .isMonitorOnly,
            member_count: (.members | length)
          },
          members: [
            .members[] | {
              serial: .serial,
              name: .name,
              model: .model,
              mac: .mac,
              role: .role
            }
          ]
        }
      }
    else empty
    end

# getNetworkSwitchStackRoutingInterfaces
cisco.meraki.networks_switch_stacks_routing_interfaces_info:
  query: >-
    if .meraki_response then
      .meraki_response[] |
      {
        name: .name,
        canonical_facts: {
          interface_id: .interfaceId,
          vlan_id: .vlanId,
          interface_ip: .interfaceIp,
          ansible_product_serial: .serial,
        },
        facts: {
          device_type: "switch",
          interface_config: {
            mode: .mode,
            subnet: .subnet,
            default_gateway: .defaultGateway,
            serial: .serial,
            switch_port_id: .switchPortId,
            multicast_routing: .multicastRouting
          },
          uplink: {
            ipv4_enabled: .uplinkV4,
            ipv6_enabled: .uplinkV6
          },
          ipv6: {
            assignment_mode: .ipv6.assignmentMode,
            address: .ipv6.address,
            prefix: .ipv6.prefix,
            gateway: .ipv6.gateway
          },
          ospf: {
            v2: {
              area: .ospfSettings.area,
              cost: .ospfSettings.cost,
              is_passive_enabled: .ospfSettings.isPassiveEnabled,
              network_type: .ospfSettings.networkType
            },
            v3: {
              area: .ospfV3.area,
              cost: .ospfV3.cost,
              is_passive_enabled: .ospfV3.isPassiveEnabled,
              network_type: .ospfV3.networkType
            }
          },
          vrf: {
            name: .vrf.name
          }
        }
      }
    else empty
    end

# updateDeviceSwitchPort
cisco.meraki.devices_switch_ports:
  query: >-
    if .meraki_response then
      .meraki_response |
      {
        name: .name,
        canonical_facts: {
          vlan_id: .vlan,
          port_id: .portId,
          ansible_product_serial: .module.serial,
        },
        facts: {
          device_type: "switch",
          port_config: {
            enabled: .enabled,
            type: .type,
            tags: .tags,
            voice_vlan: .voiceVlan,
            allowed_vlans: .allowedVlans,
            link_negotiation: .linkNegotiation,
            link_negotiation_capabilities: .linkNegotiationCapabilities
          },
          poe: {
            enabled: .poeEnabled
          },
          spanning_tree: {
            rstp_enabled: .rstpEnabled,
            stp_guard: .stpGuard
          },
          security: {
            isolation_enabled: .isolationEnabled,
            udld: .udld,
            access_policy_type: .accessPolicyType,
            access_policy_number: .accessPolicyNumber,
            mac_allow_list: .macAllowList,
            mac_whitelist_limit: .macWhitelistLimit,
            sticky_mac_allow_list: .stickyMacAllowList,
            sticky_mac_allow_list_limit: .stickyMacAllowListLimit,
            storm_control_enabled: .stormControlEnabled,
            dai_trusted: .daiTrusted,
            peer_sgt_capable: .peerSgtCapable
          },
          adaptive_policy: {
            group_id: .adaptivePolicyGroupId,
            group_name: .adaptivePolicyGroup.name
          },
          schedule: {
            id: .portScheduleId,
            name: .schedule.name
          },
          advanced: {
            flexible_stacking_enabled: .flexibleStackingEnabled,
            dot3az_enabled: .dot3az.enabled,
            high_speed_enabled: .highSpeed.enabled,
            mirror_mode: .mirror.mode
          },
          profile: {
            enabled: .profile.enabled,
            id: .profile.id,
            iname: .profile.iname
          },
          module: {
            model: .module.model,
            serial: .module.serial,
            slot: .module.slot
          }
        }
      }
    else empty
    end

# getOrganizationSwitchPortsBySwitch
cisco.meraki.organizations_switch_ports_by_switch_info:
  query: >-
    if .meraki_response then
      (.meraki_response | if type == "array" then .[] else . end) |
      {
        name: .name,
        canonical_facts: {
          ansible_product_serial: .serial,
          mac_address: .mac,
          model: .model,
        },
        facts: {
          device_type: "switch",
          switch_info: {
            network_name: .network.name,
            network_id: .network.id
          },
          ports: [
            .ports[] | {
              port_id: .portId,
              name: .name,
              tags: .tags,
              config: {
                enabled: .enabled,
                type: .type,
                vlan: .vlan,
                voice_vlan: .voiceVlan,
                allowed_vlans: .allowedVlans,
                link_negotiation: .linkNegotiation
              },
              poe: {
                enabled: .poeEnabled
              },
              spanning_tree: {
                rstp_enabled: .rstpEnabled,
                stp_guard: .stpGuard
              },
              security: {
                access_policy_type: .accessPolicyType,
                sticky_mac_allow_list: .stickyMacAllowList,
                sticky_mac_allow_list_limit: .stickyMacAllowListLimit
              }
            }
          ]
        }
      }
    else empty
    end

# getDeviceSwitchPortsStatuses
cisco.meraki.devices_switch_ports_statuses_info:
  query: >-
    if .meraki_response then
      (.meraki_response.items | if type == "array" then .[] else . end) |
      {
        name: .name,
        canonical_facts: {
          ansible_product_serial: .serial,
          mac_address: .mac,
          model: .model,
        },
        facts: {
          device_type: "switch",
          switch_info: {
            network_name: .network.name,
            network_id: .network.id
          },
          ports: [
            .ports[] | {
              port_id: .portId,
              operational_status: {
                enabled: .enabled,
                status: .status,
                is_uplink: .isUplink,
                speed: .speed,
                duplex: .duplex
              },
              health: {
                errors: .errors,
                warnings: .warnings
              },
              spanning_tree: {
                statuses: .spanningTree.statuses
              },
              poe: {
                is_allocated: .poe.isAllocated
              },
              secure_port: {
                active: .securePort.active,
                authentication_status: .securePort.authenticationStatus
              }
            }
          ],
          meta: {
            total_items: (.meta.counts.items.total // 0),
            remaining_items: (.meta.counts.items.remaining // 0)
          }
        }
      }
    else empty
    end

# getNetworkSwitchAccessPolicies
cisco.meraki.networks_switch_access_policies_info:
  query: >-
    if .meraki_response then
      (.meraki_response | if type == "array" then .[] else . end) |
      {
        name: .name,
        canonical_facts: {
          access_policy_number: .accessPolicyNumber,
          access_policy_type: .accessPolicyType,
        },
        facts: {
          device_type: "switch",
          policy_config: {
            host_mode: .hostMode,
            increase_access_speed: .increaseAccessSpeed,
            guest_vlan_id: .guestVlanId,
            guest_group_policy_id: .guestGroupPolicyId,
            guest_sgt_id: .guestSgtId,
            voice_vlan_clients: .voiceVlanClients,
            guest_port_bouncing: .guestPortBouncing
          },
          radius: {
            servers: [
              .radiusServers[] | {
                server_id: .serverId,
                organization_radius_server_id: .organizationRadiusServerId,
                host: .host,
                port: .port
              }
            ],
            accounting_enabled: .radiusAccountingEnabled,
            accounting_servers: [
              .radiusAccountingServers[] | {
                server_id: .serverId,
                organization_radius_server_id: .organizationRadiusServerId,
                host: .host,
                port: .port
              }
            ],
            group_attribute: .radiusGroupAttribute,
            testing_enabled: .radiusTestingEnabled,
            coa_support_enabled: .radiusCoaSupportEnabled,
            enforce_monitoring: .enforceRadiusMonitoring,
            critical_auth: {
              data_vlan_id: .radius.criticalAuth.dataVlanId,
              voice_vlan_id: .radius.criticalAuth.voiceVlanId,
              suspend_port_bounce: .radius.criticalAuth.suspendPortBounce,
              data_group_policy_id: .radius.criticalAuth.dataGroupPolicyId,
              voice_group_policy_id: .radius.criticalAuth.voiceGroupPolicyId,
              data_sgt_id: .radius.criticalAuth.dataSgtId,
              voice_sgt_id: .radius.criticalAuth.voiceSgtId
            },
            failed_auth: {
              vlan_id: .radius.failedAuthVlanId,
              group_policy_id: .radius.failedAuthGroupPolicyId,
              sgt_id: .radius.failedAuthSgtId
            },
            re_authentication_interval: .radius.reAuthenticationInterval,
            cache: {
              enabled: .radius.cache.enabled,
              timeout: .radius.cache.timeout
            },
            authentication: {
              mode: .radius.authentication.mode
            },
            pre_authentication_group_policy_id: .radius.preAuthenticationGroupPolicyId
          },
          dot1x: {
            control_direction: .dot1x.controlDirection
          },
          captive_portal: {
            url_redirect_walled_garden_enabled: .urlRedirectWalledGardenEnabled,
            url_redirect_walled_garden_ranges: .urlRedirectWalledGardenRanges
          },
          usage: {
            ports_with_policy: .counts.ports.withThisPolicy
          }
        }
      }
    else empty
    end

# getNetworkSwitchSettings
cisco.meraki.networks_switch_settings_info:
  query: >-
    if .meraki_response then
      .meraki_response |
      {
        name: "Network Switch Settings",
        canonical_facts: {
          vlan_id: .vlan,
        },
        facts: {
          device_type: "switch",
          power_management: {
            use_combined_power: .useCombinedPower,
            exceptions: [
              .powerExceptions[] | {
                serial: .serial,
                power_type: .powerType
              }
            ]
          },
          uplink_client_sampling: {
            enabled: .uplinkClientSampling.enabled
          },
          mac_blocklist: {
            enabled: .macBlocklist.enabled
          }
        }
      }
    else empty
    end

# updateNetworkSwitchAccessPolicy
cisco.meraki.networks_switch_access_policies:
  query: >-
    if .meraki_response then
      (.meraki_response | if type == "array" then .[] else . end) |
      {
        name: .name,
        canonical_facts: {
          access_policy_number: .accessPolicyNumber,
          access_policy_type: .accessPolicyType,
        },
        facts: {
          device_type: "switch",
          policy_config: {
            host_mode: .hostMode,
            increase_access_speed: .increaseAccessSpeed,
            guest_vlan_id: .guestVlanId,
            guest_group_policy_id: .guestGroupPolicyId,
            guest_sgt_id: .guestSgtId,
            voice_vlan_clients: .voiceVlanClients,
            guest_port_bouncing: .guestPortBouncing
          },
          radius: {
            servers: [
              .radiusServers[] | {
                server_id: .serverId,
                organization_radius_server_id: .organizationRadiusServerId,
                host: .host,
                port: .port
              }
            ],
            accounting_enabled: .radiusAccountingEnabled,
            accounting_servers: [
              .radiusAccountingServers[] | {
                server_id: .serverId,
                organization_radius_server_id: .organizationRadiusServerId,
                host: .host,
                port: .port
              }
            ],
            group_attribute: .radiusGroupAttribute,
            testing_enabled: .radiusTestingEnabled,
            coa_support_enabled: .radiusCoaSupportEnabled,
            enforce_monitoring: .enforceRadiusMonitoring,
            critical_auth: {
              data_vlan_id: .radius.criticalAuth.dataVlanId,
              voice_vlan_id: .radius.criticalAuth.voiceVlanId,
              suspend_port_bounce: .radius.criticalAuth.suspendPortBounce,
              data_group_policy_id: .radius.criticalAuth.dataGroupPolicyId,
              voice_group_policy_id: .radius.criticalAuth.voiceGroupPolicyId,
              data_sgt_id: .radius.criticalAuth.dataSgtId,
              voice_sgt_id: .radius.criticalAuth.voiceSgtId
            },
            failed_auth: {
              vlan_id: .radius.failedAuthVlanId,
              group_policy_id: .radius.failedAuthGroupPolicyId,
              sgt_id: .radius.failedAuthSgtId
            },
            re_authentication_interval: .radius.reAuthenticationInterval,
            cache: {
              enabled: .radius.cache.enabled,
              timeout: .radius.cache.timeout
            },
            authentication: {
              mode: .radius.authentication.mode
            },
            pre_authentication_group_policy_id: .radius.preAuthenticationGroupPolicyId
          },
          dot1x: {
            control_direction: .dot1x.controlDirection
          },
          captive_portal: {
            url_redirect_walled_garden_enabled: .urlRedirectWalledGardenEnabled,
            url_redirect_walled_garden_ranges: .urlRedirectWalledGardenRanges
          },
          usage: {
            ports_with_policy: .counts.ports.withThisPolicy
          }
        }
      }
    else empty
    end

# createNetworkSwitchStackRoutingInterface
cisco.meraki.networks_switch_stacks_routing_interfaces:
  query: >-
    if .meraki_response then
      (.meraki_response | if type == "array" then .[] else . end) |
      {
        name: .name,
        canonical_facts: {
          ansible_product_serial: .serial,
          interface_id: .interfaceId,
          vlan_id: .vlanId,
          interface_ip: .interfaceIp,
        },
        facts: {
          device_type: "switch",
          interface_config: {
            mode: .mode,
            subnet: .subnet,
            default_gateway: .defaultGateway,
            switch_port_id: .switchPortId,
            multicast_routing: .multicastRouting
          },
          uplink: {
            ipv4_enabled: .uplinkV4,
            ipv6_enabled: .uplinkV6
          },
          ipv6: {
            assignment_mode: .ipv6.assignmentMode,
            address: .ipv6.address,
            prefix: .ipv6.prefix,
            gateway: .ipv6.gateway
          },
          ospf: {
            v2: {
              area: .ospfSettings.area,
              cost: .ospfSettings.cost,
              is_passive_enabled: .ospfSettings.isPassiveEnabled,
              network_type: .ospfSettings.networkType
            },
            v3: {
              area: .ospfV3.area,
              cost: .ospfV3.cost,
              is_passive_enabled: .ospfV3.isPassiveEnabled,
              network_type: .ospfV3.networkType
            }
          },
          vrf: {
            name: .vrf.name
          }
        }
      }
    else empty
    end

# updateNetworkSwitchStackRoutingInterface
# Uses same module as createNetworkSwitchStackRoutingInterface

# getNetworkSwitchRoutingOspf
cisco.meraki.networks_switch_routing_ospf_info:
  query: >-
    if .meraki_response then
      (.meraki_response | if type == "array" then .[] else . end) |
      {
        name: "Network Switch Routing OSPF",
        canonical_facts: {
          ospf_config_identifier: (
            (.areas | map(.areaId) | join(",")) + "-" +
            ((.v3.areas // []) | map(.areaId) | join(",")) + "-" +
            ((.md5AuthenticationKey.id // "") | tostring)
          )
        },
        facts: {
          device_type: "switch",
          ospf_config: {
            enabled: .enabled,
            dead_timer_in_seconds: .deadTimerInSeconds,
            hello_timer_in_seconds: .helloTimerInSeconds,
            md5_authentication_enabled: .md5AuthenticationEnabled,
            md5_authentication_key: {
              id: .md5AuthenticationKey.id,
              passphrase: .md5AuthenticationKey.passphrase
            },
            areas: [
              .areas[] | {
                area_id: .areaId,
                area_name: .areaName,
                area_type: .areaType
              }
            ]
          },
          ospf_v3: {
            enabled: .v3.enabled,
            dead_timer_in_seconds: .v3.deadTimerInSeconds,
            hello_timer_in_seconds: .v3.helloTimerInSeconds,
            areas: [
              .v3.areas[] | {
                area_id: .areaId,
                area_name: .areaName,
                area_type: .areaType
              }
            ]
          }
        }
      }
    else empty
    end

# deleteNetworkSwitchAccessPolicy
# delete operation returns "meraki_response": null, handled by existing updateNetworkSwitchAccessPolicy entry

# getNetworkSwitchAlternateManagementInterface
cisco.meraki.networks_switch_alternate_management_interface_info:
  query: >-
    if .meraki_response then
      (.meraki_response | if type == "array" then .[] else . end) |
      {
        name: "Network Switch Alternate Management Interface",
        canonical_facts: {
          vlan_id: .vlanId,
          alternate_mgmt_identifier: ((.switches | map(.serial) | join(",")) + "-" + (.vlanId | tostring))
        },
        facts: {
          device_type: "switch",
          alternate_management: {
            enabled: .enabled,
            protocols: .protocols,
            vlan_id: .vlanId,
            switches: [
              .switches[] | {
                serial: .serial,
                alternate_management_ip: .alternateManagementIp,
                gateway: .gateway,
                subnet_mask: .subnetMask
              }
            ]
          }
        }
      }
    else empty
    end

# getOrganizationConfigTemplateSwitchProfiles
cisco.meraki.organizations_config_templates_switch_profiles_info:
  query: >-
    if .meraki_response then
      (.meraki_response | if type == "array" then .[] else . end) |
      {
        name: .name,
        canonical_facts: {
          switch_profile_id: .switchProfileId
        },
        facts: {
          device_type: "switch",
          profile_config: {
            model: .model
          }
        }
      }
    else empty
    end

# updateNetworkSwitchDscpToCosMappings
cisco.meraki.networks_switch_dscp_to_cos_mappings:
  query: >-
    if .meraki_response then
      (.meraki_response | if type == "array" then .[] else . end) |
      {
        name: .title,
        canonical_facts: {
          dscp: .dscp,
          cos: .cos,
          dscp_cos_mapping_id: ((.dscp | tostring) + "-" + (.cos | tostring))
        },
        facts: {
          device_type: "switch",
          dscp_to_cos_mapping: {
            dscp: .dscp,
            cos: .cos,
            title: .title
          }
        }
      }
    else empty
    end

# updateNetworkSwitchRoutingOspf
cisco.meraki.networks_switch_routing_ospf:
  query: >-
    if .meraki_response then
      (.meraki_response | if type == "array" then .[] else . end) |
      {
        name: "Network Switch Routing OSPF",
        canonical_facts: {
          ospf_config_identifier: (
            (.areas | map(.areaId) | join(",")) + "-" +
            ((.v3.areas // []) | map(.areaId) | join(",")) + "-" +
            ((.md5AuthenticationKey.id // "") | tostring)
          )
        },
        facts: {
          device_type: "switch",
          ospf_config: {
            enabled: .enabled,
            dead_timer_in_seconds: .deadTimerInSeconds,
            hello_timer_in_seconds: .helloTimerInSeconds,
            md5_authentication_enabled: .md5AuthenticationEnabled,
            md5_authentication_key: {
              id: .md5AuthenticationKey.id,
              passphrase: .md5AuthenticationKey.passphrase
            },
            areas: [
              .areas[] | {
                area_id: .areaId,
                area_name: .areaName,
                area_type: .areaType
              }
            ]
          },
          ospf_v3: {
            enabled: .v3.enabled,
            dead_timer_in_seconds: .v3.deadTimerInSeconds,
            hello_timer_in_seconds: .v3.helloTimerInSeconds,
            areas: [
              .v3.areas[] | {
                area_id: .areaId,
                area_name: .areaName,
                area_type: .areaType
              }
            ]
          }
        }
      }
    else empty
    end

# getNetworkSwitchDhcpServerPolicyArpInspectionTrustedServers
cisco.meraki.networks_switch_dhcp_server_policy_arp_inspection_trusted_servers_info:
  query: >-
    if .meraki_response then
      (.meraki_response | if type == "array" then .[] else . end) |
      {
        name: (.ipv4.address // "Trusted Server"),
        canonical_facts: {
          trusted_server_id: .trustedServerId,
          mac_address: .mac,
          vlan_id: .vlan
        },
        facts: {
          device_type: "switch",
          trusted_server: {
            ipv4_address: .ipv4.address,
            mac: .mac,
            vlan: .vlan
          }
        }
      }
    else empty
    end

# getNetworkSwitchDhcpServerPolicyArpInspectionWarningsByDevice
cisco.meraki.networks_switch_dhcp_server_policy_arp_inspection_warnings_by_device_info:
  query: >-
    if .meraki_response then
      (.meraki_response | if type == "array" then .[] else . end) |
      {
        name: .name,
        canonical_facts: {
          ansible_product_serial: .serial
        },
        facts: {
          device_type: "switch",
          arp_inspection: {
            has_trusted_port: .hasTrustedPort,
            supports_inspection: .supportsInspection,
            url: .url
          }
        }
      }
    else empty
    end

# getNetworkSwitchDhcpV4ServersSeen
cisco.meraki.networks_switch_dhcp_v4_servers_seen_info:
  query: >-
    if .meraki_response then
      (.meraki_response | if type == "array" then .[] else . end) |
      {
        name: (.device.name // .mac),
        canonical_facts: {
          mac_address: .mac,
          client_id: .clientId,
          vlan_id: .vlan,
          dhcp_server_id: ((.mac // "") + "-" + (.clientId // "") + "-" + (.vlan | tostring))
        },
        facts: {
          device_type: "switch",
          dhcp_server: {
            ipv4: {
              address: .ipv4.address,
              gateway: .ipv4.gateway,
              subnet: .ipv4.subnet
            },
            device: {
              serial: .device.serial,
              name: .device.name,
              url: .device.url,
              interface: {
                name: .device.interface.name,
                url: .device.interface.url
              }
            },
            is_allowed: .isAllowed,
            is_configured: .isConfigured,
            type: .type,
            last_seen_at: .lastSeenAt,
            seen_by: [
              .seenBy[] | {
                serial: .serial,
                name: .name,
                url: .url
              }
            ]
          }
        }
      }
    else empty
    end

# getNetworkSwitchLinkAggregations
cisco.meraki.networks_switch_link_aggregations_info:
  query: >-
    if .meraki_response then
      (.meraki_response | if type == "array" then .[] else . end) |
      {
        name: .id,
        canonical_facts: {
          link_aggregation_id: .id
        },
        facts: {
          device_type: "switch",
          link_aggregation: {
            switch_ports: [
              .switchPorts[] | {
                serial: .serial,
                port_id: .portId
              }
            ]
          }
        }
      }
    else empty
    end

# getNetworkSwitchQosRules
cisco.meraki.networks_switch_qos_rules_order_info:
  query: >-
    if .meraki_response then
      (.meraki_response | if type == "array" then .[] else . end) |
      {
        name: .id,
        canonical_facts: {
          qos_rule_id: .id,
          vlan_id: .vlan
        },
        facts: {
          device_type: "switch",
          qos_rule: {
            dscp: .dscp,
            dst_port: .dstPort,
            dst_port_range: .dstPortRange,
            protocol: .protocol,
            src_port: .srcPort,
            src_port_range: .srcPortRange,
            vlan: .vlan
          }
        }
      }
    else empty
    end

# getNetworkSwitchPortSchedules
cisco.meraki.networks_switch_port_schedules_info:
  query: >-
    if .meraki_response then
      (.meraki_response | if type == "array" then .[] else . end) |
      {
        name: .name,
        canonical_facts: {
          port_schedule_id: .id,
          network_id: .networkId
        },
        facts: {
          device_type: "switch",
          port_schedule: {
            schedule: {
              monday: {
                active: .portSchedule.monday.active,
                from: .portSchedule.monday.from,
                to: .portSchedule.monday.to
              },
              tuesday: {
                active: .portSchedule.tuesday.active,
                from: .portSchedule.tuesday.from,
                to: .portSchedule.tuesday.to
              },
              wednesday: {
                active: .portSchedule.wednesday.active,
                from: .portSchedule.wednesday.from,
                to: .portSchedule.wednesday.to
              },
              thursday: {
                active: .portSchedule.thursday.active,
                from: .portSchedule.thursday.from,
                to: .portSchedule.thursday.to
              },
              friday: {
                active: .portSchedule.friday.active,
                from: .portSchedule.friday.from,
                to: .portSchedule.friday.to
              },
              saturday: {
                active: .portSchedule.saturday.active,
                from: .portSchedule.saturday.from,
                to: .portSchedule.saturday.to
              },
              sunday: {
                active: .portSchedule.sunday.active,
                from: .portSchedule.sunday.from,
                to: .portSchedule.sunday.to
              }
            }
          }
        }
      }
    else empty
    end

# getNetworkSwitchRoutingMulticastRendezvousPoints
cisco.meraki.networks_switch_routing_multicast_rendezvous_points_info:
  query: >-
    if .meraki_response then
      (.meraki_response | if type == "array" then .[] else . end) |
      {
        name: (.interfaceName // .rendezvousPointId),
        canonical_facts: {
          rendezvous_point_id: .rendezvousPointId,
          ansible_product_serial: .serial
        },
        facts: {
          device_type: "switch",
          rendezvous_point: {
            interface_ip: .interfaceIp,
            interface_name: .interfaceName,
            multicast_group: .multicastGroup
          }
        }
      }
    else empty
    end

# getDeviceSwitchRoutingStaticRoutes
cisco.meraki.devices_switch_routing_static_routes_info:
  query: >-
    if .meraki_response then
      (.meraki_response | if type == "array" then .[] else . end) |
      {
        name: .name,
        canonical_facts: {
          static_route_id: .staticRouteId,
          subnet: .subnet,
          route_identifier: ((.staticRouteId // "") + "-" + (.subnet // ""))
        },
        facts: {
          device_type: "switch",
          static_route: {
            advertise_via_ospf_enabled: .advertiseViaOspfEnabled,
            management_next_hop: .managementNextHop,
            next_hop_ip: .nextHopIp,
            prefer_over_ospf_routes_enabled: .preferOverOspfRoutesEnabled,
            subnet: .subnet
          }
        }
      }
    else empty
    end

# updateDeviceSwitchRoutingInterface
cisco.meraki.devices_switch_routing_interfaces:
  query: >-
    if .meraki_response then
      (.meraki_response | if type == "array" then .[] else . end) |
      {
        name: .name,
        canonical_facts: {
          interface_id: .interfaceId,
          vlan_id: .vlanId,
          interface_ip: .interfaceIp,
          interface_identifier: ((.interfaceId // "") + "-" + (.vlanId | tostring) + "-" + (.interfaceIp // ""))
        },
        facts: {
          device_type: "switch",
          interface_config: {
            default_gateway: .defaultGateway,
            subnet: .subnet,
            multicast_routing: .multicastRouting
          },
          uplink: {
            ipv4_enabled: .uplinkV4,
            ipv6_enabled: .uplinkV6
          },
          ipv6: {
            assignment_mode: .ipv6.assignmentMode,
            address: .ipv6.address,
            prefix: .ipv6.prefix,
            gateway: .ipv6.gateway
          },
          ospf: {
            v2: {
              area: .ospfSettings.area,
              cost: .ospfSettings.cost,
              is_passive_enabled: .ospfSettings.isPassiveEnabled
            },
            v3: {
              area: .ospfV3.area,
              cost: .ospfV3.cost,
              is_passive_enabled: .ospfV3.isPassiveEnabled
            }
          }
        }
      }
    else empty
    end

# getDeviceSwitchRoutingInterface
cisco.meraki.devices_switch_routing_interfaces_info:
  query: >-
    if .meraki_response then
      (.meraki_response | if type == "array" then .[] else . end) |
      {
        name: .name,
        canonical_facts: {
          interface_id: .interfaceId,
          vlan_id: .vlanId,
          interface_ip: .interfaceIp,
          interface_identifier: ((.interfaceId // "") + "-" + (.vlanId | tostring) + "-" + (.interfaceIp // ""))
        },
        facts: {
          device_type: "switch",
          interface_config: {
            default_gateway: .defaultGateway,
            subnet: .subnet,
            multicast_routing: .multicastRouting
          },
          uplink: {
            ipv4_enabled: .uplinkV4,
            ipv6_enabled: .uplinkV6
          },
          ipv6: {
            assignment_mode: .ipv6.assignmentMode,
            address: .ipv6.address,
            prefix: .ipv6.prefix,
            gateway: .ipv6.gateway
          },
          ospf: {
            v2: {
              area: .ospfSettings.area,
              cost: .ospfSettings.cost,
              is_passive_enabled: .ospfSettings.isPassiveEnabled
            },
            v3: {
              area: .ospfV3.area,
              cost: .ospfV3.cost,
              is_passive_enabled: .ospfV3.isPassiveEnabled
            }
          }
        }
      }
    else empty
    end

# removeNetworkSwitchStack
# delete operation returns "meraki_response": null

# getOrganizationConfigTemplateSwitchProfilePorts
cisco.meraki.organizations_config_templates_switch_profiles_ports_info:
  query: >-
    if .meraki_response then
      (.meraki_response | if type == "array" then .[] else . end) |
      {
        name: .name,
        canonical_facts: {
          port_id: .portId,
          profile_port_id: ((.portId // "") + "-" + (.profile.id // ""))
        },
        facts: {
          device_type: "switch",
          port_config: {
            enabled: .enabled,
            type: .type,
            tags: .tags,
            vlan: .vlan,
            voice_vlan: .voiceVlan,
            allowed_vlans: .allowedVlans,
            link_negotiation: .linkNegotiation,
            link_negotiation_capabilities: .linkNegotiationCapabilities,
            access_policy_type: .accessPolicyType,
            access_policy_number: .accessPolicyNumber,
            isolation_enabled: .isolationEnabled,
            rstp_enabled: .rstpEnabled,
            stp_guard: .stpGuard,
            poe_enabled: .poeEnabled,
            dai_trusted: .daiTrusted,
            mac_allow_list: .macAllowList,
            sticky_mac_allow_list: .stickyMacAllowList,
            sticky_mac_allow_list_limit: .stickyMacAllowListLimit,
            storm_control_enabled: .stormControlEnabled,
            flexible_stacking_enabled: .flexibleStackingEnabled,
            udld: .udld,
            port_schedule_id: .portScheduleId
          },
          module: {
            model: .module.model
          },
          profile: {
            enabled: .profile.enabled,
            id: .profile.id,
            iname: .profile.iname
          },
          schedule: {
            id: .schedule.id,
            name: .schedule.name
          },
          dot3az: {
            enabled: .dot3az.enabled
          },
          mirror: {
            mode: .mirror.mode
          },
          stackwise_virtual: {
            is_dual_active_detector: .stackwiseVirtual.isDualActiveDetector,
            is_stack_wise_virtual_link: .stackwiseVirtual.isStackWiseVirtualLink
          }
        }
      }
    else empty
    end

# getDeviceSwitchWarmSpare
cisco.meraki.devices_switch_warm_spare_info:
  query: >-
    if .meraki_response then
      .meraki_response |
      {
        name: "Device Switch Warm Spare",
        canonical_facts: {
          primary_serial: .primarySerial,
          spare_serial: .spareSerial
        },
        facts: {
          device_type: "switch",
          warm_spare: {
            enabled: .enabled,
            primary_serial: .primarySerial,
            spare_serial: .spareSerial
          }
        }
      }
    else empty
    end

# createDeviceSwitchRoutingStaticRoute
cisco.meraki.devices_switch_routing_static_routes:
  query: >-
    if .meraki_response then
      (.meraki_response | if type == "array" then .[] else . end) |
      {
        name: .name,
        canonical_facts: {
          static_route_id: .staticRouteId,
          subnet: .subnet,
          route_identifier: ((.staticRouteId // "") + "-" + (.subnet // ""))
        },
        facts: {
          device_type: "switch",
          static_route: {
            advertise_via_ospf_enabled: .advertiseViaOspfEnabled,
            management_next_hop: .managementNextHop,
            next_hop_ip: .nextHopIp,
            prefer_over_ospf_routes_enabled: .preferOverOspfRoutesEnabled,
            subnet: .subnet
          }
        }
      }
    else empty
    end

# getOrganizationSummaryTopSwitchesByEnergyUsage
cisco.meraki.organizations_summary_top_switches_by_energy_usage_info:
  query: >-
    if .meraki_response then
      (.meraki_response | if type == "array" then .[] else . end) |
      {
        name: .name,
        canonical_facts: {
          ansible_product_serial: (.serial // ""),
          mac_address: .mac,
          model: .model
        },
        facts: {
          device_type: "switch",
          network: {
            id: .network.id,
            name: .network.name
          },
          energy_usage: {
            total: .usage.total
          }
        }
      }
    else empty
    end

# addNetworkSwitchStack
# Uses same module as getNetworkSwitchStack (networks_switch_stacks_info)

# getDeviceSwitchRoutingInterfaceDhcp
cisco.meraki.devices_switch_routing_interfaces_dhcp_info:
  query: >-
    if .meraki_response then
      (.meraki_response | if type == "array" then .[] else . end) |
      {
        name: "Device Switch Routing Interface DHCP",
        canonical_facts: {
          dhcp_config_identifier: ((.dhcpMode // "") + "-" + (.dhcpLeaseTime // "") + "-" + ((.dhcpOptions | length) | tostring))
        },
        facts: {
          device_type: "switch",
          dhcp_config: {
            dhcp_mode: .dhcpMode,
            dhcp_lease_time: .dhcpLeaseTime,
            dhcp_options: [
              .dhcpOptions[] | {
                code: .code,
                type: .type,
                value: .value
              }
            ],
            dhcp_relay_server_ips: .dhcpRelayServerIps,
            dns_nameservers_option: .dnsNameserversOption,
            dns_custom_nameservers: .dnsCustomNameservers,
            boot_options_enabled: .bootOptionsEnabled,
            boot_next_server: .bootNextServer,
            boot_file_name: .bootFileName,
            fixed_ip_assignments: [
              .fixedIpAssignments[] | {
                ip: .ip,
                mac: .mac,
                name: .name
              }
            ],
            reserved_ip_ranges: [
              .reservedIpRanges[] | {
                start: .start,
                end: .end,
                comment: .comment
              }
            ]
          }
        }
      }
    else empty
    end

# updateDeviceSwitchRoutingInterfaceDhcp
cisco.meraki.devices_switch_routing_interfaces_dhcp:
  query: >-
    if .meraki_response then
      (.meraki_response | if type == "array" then .[] else . end) |
      {
        name: "Device Switch Routing Interface DHCP",
        canonical_facts: {
          dhcp_config_identifier: ((.dhcpMode // "") + "-" + (.dhcpLeaseTime // "") + "-" + ((.dhcpOptions | length) | tostring))
        },
        facts: {
          device_type: "switch",
          dhcp_config: {
            dhcp_mode: .dhcpMode,
            dhcp_lease_time: .dhcpLeaseTime,
            dhcp_options: [
              .dhcpOptions[] | {
                code: .code,
                type: .type,
                value: .value
              }
            ],
            dhcp_relay_server_ips: .dhcpRelayServerIps,
            dns_nameservers_option: .dnsNameserversOption,
            dns_custom_nameservers: .dnsCustomNameservers,
            boot_options_enabled: .bootOptionsEnabled,
            boot_next_server: .bootNextServer,
            boot_file_name: .bootFileName,
            fixed_ip_assignments: [
              .fixedIpAssignments[] | {
                ip: .ip,
                mac: .mac,
                name: .name
              }
            ],
            reserved_ip_ranges: [
              .reservedIpRanges[] | {
                start: .start,
                end: .end,
                comment: .comment
              }
            ]
          }
        }
      }
    else empty
    end

# updateNetworkSwitchRoutingMulticast
cisco.meraki.networks_switch_routing_multicast:
  query: >-
    if .meraki_response then
      (.meraki_response | if type == "array" then .[] else . end) |
      {
        name: "Network Switch Routing Multicast",
        canonical_facts: {
          multicast_config_identifier: (
            (.defaultSettings.floodUnknownMulticastTrafficEnabled | tostring) + "-" +
            (.defaultSettings.igmpSnoopingEnabled | tostring) + "-" +
            ((.overrides | length) | tostring)
          )
        },
        facts: {
          device_type: "switch",
          multicast_config: {
            default_settings: {
              flood_unknown_multicast_traffic_enabled: .defaultSettings.floodUnknownMulticastTrafficEnabled,
              igmp_snooping_enabled: .defaultSettings.igmpSnoopingEnabled
            },
            overrides: [
              .overrides[] | {
                flood_unknown_multicast_traffic_enabled: .floodUnknownMulticastTrafficEnabled,
                igmp_snooping_enabled: .igmpSnoopingEnabled,
                stacks: .stacks,
                switch_profiles: .switchProfiles,
                switches: .switches
              }
            ]
          }
        }
      }
    else empty
    end
