---
# Networks
cisco.meraki.networks_info:
  query: >-
    .meraki_response | [.] | flatten |
     map({
        name: .name,
        canonical_facts: {
          network_id: .id,
          org_id: .organizationId
        },
        facts: {
          device_type: "network"
        }
      })
    | .[]

# delete operation returns "meraki_response": null
cisco.meraki.networks:
  query: >-
    if .meraki_response then
      .meraki_response |
      {
        name: .name,
        canonical_facts: {
          network_id: .id,
          org_id: .organizationId
        },
        facts: {
            device_type: "switch"
        }
      }
    else empty
    end

# Devices
cisco.meraki.devices_info:
  query: >-
    .meraki_response | [.] | flatten |
      map({
          name: ((.name | select(. != "")) // (.productType + "-" + .serial)),
          canonical_facts: {
            ansible_product_serial: .serial,
            macaddress: .mac
          },
          facts: {
            device_type: .productType,
            meraki_network_id: .networkId,
            ansible_hostname: (.lanIp // ""),
            ansible_product_name: .model,
            ansible_bios_version: .firmware,
          }
        })
      | .[]

# updateDevice does not seem to return productType field
cisco.meraki.devices:
  query: >-
    .meraki_response | [.] | flatten |
      map({
          name: ((.name | select(. != "")) // (.model + "-" + .serial)),
          canonical_facts: {
            ansible_product_serial: .serial,
            macaddress: .mac
          },
          facts: {
            device_type: (if .model | startswith("MV") then "camera"
                      elif .model | startswith("MR") then "wireless"
                      elif .model | startswith("MS") then "switch"
                      elif .model | startswith("MX") then "appliance"
                      else "unknown"
                      end),
            meraki_network_id: .networkId,
            ansible_hostname: (.lanIp // ""),
            ansible_product_name: .model,
            ansible_bios_version: .firmware,
          }
        })
      | .[]

# getDeviceSwitchPort
cisco.meraki.devices_switch_ports_info:
  query: >-
    if .meraki_response then
      .meraki_response |
      {
        name: .name,
        canonical_facts: {
          vlan_id: .vlan,
          port_id: .portId,
          ansible_product_serial: .module.serial,
        },
        facts: {
          device_type: "switch",
          port_config: {
            enabled: .enabled,
            type: .type,
            tags: .tags,
            voice_vlan: .voiceVlan,
            allowed_vlans: .allowedVlans,
            link_negotiation: .linkNegotiation,
            link_negotiation_capabilities: .linkNegotiationCapabilities
          },
          poe: {
            enabled: .poeEnabled
          },
          spanning_tree: {
            rstp_enabled: .rstpEnabled,
            stp_guard: .stpGuard
          },
          security: {
            isolation_enabled: .isolationEnabled,
            udld: .udld,
            access_policy_type: .accessPolicyType,
            access_policy_number: .accessPolicyNumber,
            mac_allow_list: .macAllowList,
            mac_whitelist_limit: .macWhitelistLimit,
            sticky_mac_allow_list: .stickyMacAllowList,
            sticky_mac_allow_list_limit: .stickyMacAllowListLimit,
            storm_control_enabled: .stormControlEnabled,
            dai_trusted: .daiTrusted,
            peer_sgt_capable: .peerSgtCapable
          },
          adaptive_policy: {
            group_id: .adaptivePolicyGroupId,
            group_name: .adaptivePolicyGroup.name
          },
          schedule: {
            id: .portScheduleId,
            name: .schedule.name
          },
          advanced: {
            flexible_stacking_enabled: .flexibleStackingEnabled,
            dot3az_enabled: .dot3az.enabled,
            high_speed_enabled: .highSpeed.enabled,
            mirror_mode: .mirror.mode
          },
          profile: {
            enabled: .profile.enabled,
            id: .profile.id,
            iname: .profile.iname
          },
          module: {
            model: .module.model,
            serial: .module.serial,
            slot: .module.slot
          }
        }
      }
    else empty
    end

# getNetworkSwitchMtu
cisco.meraki.networks_switch_mtu_info:
  query: >-
    if .meraki_response then
      .meraki_response |
      {
        name: .name,
        canonical_facts: {
          defaultMtuSize: .defaultMtuSize,
          overrides: .overrides,
        },
        facts: {
            device_type: "switch"
        }
      }
    else empty
    end

# getNetworkSwitchStack
cisco.meraki.networks_switch_stacks_info:
  query: >-
    if .meraki_response then
      .meraki_response |
      {
        name: .name,
        canonical_facts: {
          stack_id: .id,
          virtual_mac: .virtualMac,
        },
        facts: {
          device_type: "switch",
          stack_config: {
            serials: .serials,
            is_monitor_only: .isMonitorOnly,
            member_count: (.members | length)
          },
          members: [
            .members[] | {
              serial: .serial,
              name: .name,
              model: .model,
              mac: .mac,
              role: .role
            }
          ]
        }
      }
    else empty
    end

# getNetworkSwitchStackRoutingInterfaces
cisco.meraki.networks_switch_stacks_routing_interfaces_info:
  query: >-
    if .meraki_response then
      .meraki_response[] |
      {
        name: .name,
        canonical_facts: {
          interface_id: .interfaceId,
          vlan_id: .vlanId,
          interface_ip: .interfaceIp,
          ansible_product_serial: .serial,
        },
        facts: {
          device_type: "switch",
          interface_config: {
            mode: .mode,
            subnet: .subnet,
            default_gateway: .defaultGateway,
            serial: .serial,
            switch_port_id: .switchPortId,
            multicast_routing: .multicastRouting
          },
          uplink: {
            ipv4_enabled: .uplinkV4,
            ipv6_enabled: .uplinkV6
          },
          ipv6: {
            assignment_mode: .ipv6.assignmentMode,
            address: .ipv6.address,
            prefix: .ipv6.prefix,
            gateway: .ipv6.gateway
          },
          ospf: {
            v2: {
              area: .ospfSettings.area,
              cost: .ospfSettings.cost,
              is_passive_enabled: .ospfSettings.isPassiveEnabled,
              network_type: .ospfSettings.networkType
            },
            v3: {
              area: .ospfV3.area,
              cost: .ospfV3.cost,
              is_passive_enabled: .ospfV3.isPassiveEnabled,
              network_type: .ospfV3.networkType
            }
          },
          vrf: {
            name: .vrf.name
          }
        }
      }
    else empty
    end

# updateDeviceSwitchPort
cisco.meraki.devices_switch_ports:
  query: >-
    if .meraki_response then
      .meraki_response |
      {
        name: .name,
        canonical_facts: {
          vlan_id: .vlan,
          port_id: .portId,
          ansible_product_serial: .module.serial,
        },
        facts: {
          device_type: "switch",
          port_config: {
            enabled: .enabled,
            type: .type,
            tags: .tags,
            voice_vlan: .voiceVlan,
            allowed_vlans: .allowedVlans,
            link_negotiation: .linkNegotiation,
            link_negotiation_capabilities: .linkNegotiationCapabilities
          },
          poe: {
            enabled: .poeEnabled
          },
          spanning_tree: {
            rstp_enabled: .rstpEnabled,
            stp_guard: .stpGuard
          },
          security: {
            isolation_enabled: .isolationEnabled,
            udld: .udld,
            access_policy_type: .accessPolicyType,
            access_policy_number: .accessPolicyNumber,
            mac_allow_list: .macAllowList,
            mac_whitelist_limit: .macWhitelistLimit,
            sticky_mac_allow_list: .stickyMacAllowList,
            sticky_mac_allow_list_limit: .stickyMacAllowListLimit,
            storm_control_enabled: .stormControlEnabled,
            dai_trusted: .daiTrusted,
            peer_sgt_capable: .peerSgtCapable
          },
          adaptive_policy: {
            group_id: .adaptivePolicyGroupId,
            group_name: .adaptivePolicyGroup.name
          },
          schedule: {
            id: .portScheduleId,
            name: .schedule.name
          },
          advanced: {
            flexible_stacking_enabled: .flexibleStackingEnabled,
            dot3az_enabled: .dot3az.enabled,
            high_speed_enabled: .highSpeed.enabled,
            mirror_mode: .mirror.mode
          },
          profile: {
            enabled: .profile.enabled,
            id: .profile.id,
            iname: .profile.iname
          },
          module: {
            model: .module.model,
            serial: .module.serial,
            slot: .module.slot
          }
        }
      }
    else empty
    end

# getOrganizationSwitchPortsBySwitch
cisco.meraki.organizations_switch_ports_by_switch_info:
  query: >-
    if .meraki_response then
      (.meraki_response | if type == "array" then .[] else . end) |
      {
        name: .name,
        canonical_facts: {
          ansible_product_serial: .serial,
          mac_address: .mac,
          model: .model,
        },
        facts: {
          device_type: "switch",
          switch_info: {
            network_name: .network.name,
            network_id: .network.id
          },
          ports: [
            .ports[] | {
              port_id: .portId,
              name: .name,
              tags: .tags,
              config: {
                enabled: .enabled,
                type: .type,
                vlan: .vlan,
                voice_vlan: .voiceVlan,
                allowed_vlans: .allowedVlans,
                link_negotiation: .linkNegotiation
              },
              poe: {
                enabled: .poeEnabled
              },
              spanning_tree: {
                rstp_enabled: .rstpEnabled,
                stp_guard: .stpGuard
              },
              security: {
                access_policy_type: .accessPolicyType,
                sticky_mac_allow_list: .stickyMacAllowList,
                sticky_mac_allow_list_limit: .stickyMacAllowListLimit
              }
            }
          ]
        }
      }
    else empty
    end

# getDeviceSwitchPortsStatuses
cisco.meraki.devices_switch_ports_statuses_info:
  query: >-
    if .meraki_response then
      (.meraki_response.items | if type == "array" then .[] else . end) |
      {
        name: .name,
        canonical_facts: {
          ansible_product_serial: .serial,
          mac_address: .mac,
          model: .model,
        },
        facts: {
          device_type: "switch",
          switch_info: {
            network_name: .network.name,
            network_id: .network.id
          },
          ports: [
            .ports[] | {
              port_id: .portId,
              operational_status: {
                enabled: .enabled,
                status: .status,
                is_uplink: .isUplink,
                speed: .speed,
                duplex: .duplex
              },
              health: {
                errors: .errors,
                warnings: .warnings
              },
              spanning_tree: {
                statuses: .spanningTree.statuses
              },
              poe: {
                is_allocated: .poe.isAllocated
              },
              secure_port: {
                active: .securePort.active,
                authentication_status: .securePort.authenticationStatus
              }
            }
          ],
          meta: {
            total_items: (.meta.counts.items.total // 0),
            remaining_items: (.meta.counts.items.remaining // 0)
          }
        }
      }
    else empty
    end

# getNetworkSwitchAccessPolicies
cisco.meraki.networks_switch_access_policies_info:
  query: >-
    if .meraki_response then
      (.meraki_response | if type == "array" then .[] else . end) |
      {
        name: .name,
        canonical_facts: {
          access_policy_number: .accessPolicyNumber,
          access_policy_type: .accessPolicyType,
        },
        facts: {
          device_type: "switch",
          policy_config: {
            host_mode: .hostMode,
            increase_access_speed: .increaseAccessSpeed,
            guest_vlan_id: .guestVlanId,
            guest_group_policy_id: .guestGroupPolicyId,
            guest_sgt_id: .guestSgtId,
            voice_vlan_clients: .voiceVlanClients,
            guest_port_bouncing: .guestPortBouncing
          },
          radius: {
            servers: [
              .radiusServers[] | {
                server_id: .serverId,
                organization_radius_server_id: .organizationRadiusServerId,
                host: .host,
                port: .port
              }
            ],
            accounting_enabled: .radiusAccountingEnabled,
            accounting_servers: [
              .radiusAccountingServers[] | {
                server_id: .serverId,
                organization_radius_server_id: .organizationRadiusServerId,
                host: .host,
                port: .port
              }
            ],
            group_attribute: .radiusGroupAttribute,
            testing_enabled: .radiusTestingEnabled,
            coa_support_enabled: .radiusCoaSupportEnabled,
            enforce_monitoring: .enforceRadiusMonitoring,
            critical_auth: {
              data_vlan_id: .radius.criticalAuth.dataVlanId,
              voice_vlan_id: .radius.criticalAuth.voiceVlanId,
              suspend_port_bounce: .radius.criticalAuth.suspendPortBounce,
              data_group_policy_id: .radius.criticalAuth.dataGroupPolicyId,
              voice_group_policy_id: .radius.criticalAuth.voiceGroupPolicyId,
              data_sgt_id: .radius.criticalAuth.dataSgtId,
              voice_sgt_id: .radius.criticalAuth.voiceSgtId
            },
            failed_auth: {
              vlan_id: .radius.failedAuthVlanId,
              group_policy_id: .radius.failedAuthGroupPolicyId,
              sgt_id: .radius.failedAuthSgtId
            },
            re_authentication_interval: .radius.reAuthenticationInterval,
            cache: {
              enabled: .radius.cache.enabled,
              timeout: .radius.cache.timeout
            },
            authentication: {
              mode: .radius.authentication.mode
            },
            pre_authentication_group_policy_id: .radius.preAuthenticationGroupPolicyId
          },
          dot1x: {
            control_direction: .dot1x.controlDirection
          },
          captive_portal: {
            url_redirect_walled_garden_enabled: .urlRedirectWalledGardenEnabled,
            url_redirect_walled_garden_ranges: .urlRedirectWalledGardenRanges
          },
          usage: {
            ports_with_policy: .counts.ports.withThisPolicy
          }
        }
      }
    else empty
    end

# getNetworkSwitchSettings
cisco.meraki.networks_switch_settings_info:
  query: >-
    if .meraki_response then
      .meraki_response |
      {
        name: "Network Switch Settings",
        canonical_facts: {
          vlan_id: .vlan,
        },
        facts: {
          device_type: "switch",
          power_management: {
            use_combined_power: .useCombinedPower,
            exceptions: [
              .powerExceptions[] | {
                serial: .serial,
                power_type: .powerType
              }
            ]
          },
          uplink_client_sampling: {
            enabled: .uplinkClientSampling.enabled
          },
          mac_blocklist: {
            enabled: .macBlocklist.enabled
          }
        }
      }
    else empty
    end

# updateNetworkSwitchAccessPolicy
cisco.meraki.networks_switch_access_policies:
  query: >-
    if .meraki_response then
      (.meraki_response | if type == "array" then .[] else . end) |
      {
        name: .name,
        canonical_facts: {
          access_policy_number: .accessPolicyNumber,
          access_policy_type: .accessPolicyType,
        },
        facts: {
          device_type: "switch",
          policy_config: {
            host_mode: .hostMode,
            increase_access_speed: .increaseAccessSpeed,
            guest_vlan_id: .guestVlanId,
            guest_group_policy_id: .guestGroupPolicyId,
            guest_sgt_id: .guestSgtId,
            voice_vlan_clients: .voiceVlanClients,
            guest_port_bouncing: .guestPortBouncing
          },
          radius: {
            servers: [
              .radiusServers[] | {
                server_id: .serverId,
                organization_radius_server_id: .organizationRadiusServerId,
                host: .host,
                port: .port
              }
            ],
            accounting_enabled: .radiusAccountingEnabled,
            accounting_servers: [
              .radiusAccountingServers[] | {
                server_id: .serverId,
                organization_radius_server_id: .organizationRadiusServerId,
                host: .host,
                port: .port
              }
            ],
            group_attribute: .radiusGroupAttribute,
            testing_enabled: .radiusTestingEnabled,
            coa_support_enabled: .radiusCoaSupportEnabled,
            enforce_monitoring: .enforceRadiusMonitoring,
            critical_auth: {
              data_vlan_id: .radius.criticalAuth.dataVlanId,
              voice_vlan_id: .radius.criticalAuth.voiceVlanId,
              suspend_port_bounce: .radius.criticalAuth.suspendPortBounce,
              data_group_policy_id: .radius.criticalAuth.dataGroupPolicyId,
              voice_group_policy_id: .radius.criticalAuth.voiceGroupPolicyId,
              data_sgt_id: .radius.criticalAuth.dataSgtId,
              voice_sgt_id: .radius.criticalAuth.voiceSgtId
            },
            failed_auth: {
              vlan_id: .radius.failedAuthVlanId,
              group_policy_id: .radius.failedAuthGroupPolicyId,
              sgt_id: .radius.failedAuthSgtId
            },
            re_authentication_interval: .radius.reAuthenticationInterval,
            cache: {
              enabled: .radius.cache.enabled,
              timeout: .radius.cache.timeout
            },
            authentication: {
              mode: .radius.authentication.mode
            },
            pre_authentication_group_policy_id: .radius.preAuthenticationGroupPolicyId
          },
          dot1x: {
            control_direction: .dot1x.controlDirection
          },
          captive_portal: {
            url_redirect_walled_garden_enabled: .urlRedirectWalledGardenEnabled,
            url_redirect_walled_garden_ranges: .urlRedirectWalledGardenRanges
          },
          usage: {
            ports_with_policy: .counts.ports.withThisPolicy
          }
        }
      }
    else empty
    end

# createNetworkSwitchStackRoutingInterface
cisco.meraki.networks_switch_stacks_routing_interfaces:
  query: >-
    if .meraki_response then
      (.meraki_response | if type == "array" then .[] else . end) |
      {
        name: .name,
        canonical_facts: {
          ansible_product_serial: .serial,
          interface_id: .interfaceId,
          vlan_id: .vlanId,
          interface_ip: .interfaceIp,
        },
        facts: {
          device_type: "switch",
          interface_config: {
            mode: .mode,
            subnet: .subnet,
            default_gateway: .defaultGateway,
            switch_port_id: .switchPortId,
            multicast_routing: .multicastRouting
          },
          uplink: {
            ipv4_enabled: .uplinkV4,
            ipv6_enabled: .uplinkV6
          },
          ipv6: {
            assignment_mode: .ipv6.assignmentMode,
            address: .ipv6.address,
            prefix: .ipv6.prefix,
            gateway: .ipv6.gateway
          },
          ospf: {
            v2: {
              area: .ospfSettings.area,
              cost: .ospfSettings.cost,
              is_passive_enabled: .ospfSettings.isPassiveEnabled,
              network_type: .ospfSettings.networkType
            },
            v3: {
              area: .ospfV3.area,
              cost: .ospfV3.cost,
              is_passive_enabled: .ospfV3.isPassiveEnabled,
              network_type: .ospfV3.networkType
            }
          },
          vrf: {
            name: .vrf.name
          }
        }
      }
    else empty
    end

